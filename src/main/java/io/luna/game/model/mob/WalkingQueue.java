package io.luna.game.model.mob;

import io.luna.game.model.Direction;
import io.luna.game.model.EntityType;
import io.luna.game.model.Locatable;
import io.luna.game.model.Position;

import java.util.ArrayDeque;
import java.util.Deque;
import java.util.Queue;

/**
 * A model representing a walking queue for a {@link Mob}.
 * <p>
 * This class does <strong>not</strong> perform any path validation or collision checks. It will blindly follow
 * whatever sequence of {@link Position} tiles it is given. Higher-level systems (such as {@link WalkingNavigator}) are
 * responsible for generating valid paths and avoiding blocked tiles.
 *
 * @author lare96
 */
public final class WalkingQueue {

    /**
     * The mob that owns this walking queue.
     */
    private final Mob mob;

    /**
     * Whether movement is currently locked for this mob.
     * <p>
     * When locked, all queued steps are cleared and no movement is processed.
     */
    private boolean locked;

    /**
     * Whether the current path should be processed as a running path.
     * <p>
     * When true, up to two steps will be processed per cycle (if run energy allows it).
     */
    private boolean running;

    /**
     * The deque of upcoming steps to process for this mob.
     * <p>
     * This represents the forward walking path. Each position is a tile the mob will move onto
     * in order as {@link #process()} is called every cycle.
     */
    private final Deque<Position> current = new ArrayDeque<>();

    /**
     * The deque of previously visited steps for this mob.
     * <p>
     * History is used when queuing a new path that starts on a tile the mob recently walked through.
     * In that case, the queue can "backtrack" using this history to smoothly splice the new path
     * into the old one without teleporting or snapping.
     */
    private final Deque<Position> history = new ArrayDeque<>();

    /**
     * Creates a new {@link WalkingQueue} for the specified mob.
     *
     * @param mob The owning mob.
     */
    public WalkingQueue(Mob mob) {
        this.mob = mob;
    }

    /**
     * Processes this walking queue for a single game cycle.
     * <p>
     * This method:
     * <ol>
     *     <li>Aborts if the mob is stationary or movement-locked, clearing the queue.</li>
     *     <li>Consumes one step as the walking step, updating the mob's walking direction.</li>
     *     <li>If running is enabled and the player has enough run energy, consumes a second step
     *         as the running step, updating the mob's running direction.</li>
     *     <li>Updates the mob's position and maintains the history of visited tiles.</li>
     *     <li>Depletes or restores run energy for players as appropriate.</li>
     * </ol>
     */
    public void process() {
        // Ignore processing and clear queue for stationary NPCs and locked mobs.
        if ((mob instanceof Npc && mob.asNpc().isStationary()) || locked || mob.isLocked()) {
            clear();
            mob.setWalkingDirection(Direction.NONE);
            mob.setRunningDirection(Direction.NONE);
            incrementRunEnergy();
            return;
        }

        // Prepare required values for path processing.
        Position currentStep = mob.getPosition();
        int plane = mob.getZ();

        Position nextStep = current.poll();
        if (nextStep == null) {
            // No steps to process this cycle.
            mob.setWalkingDirection(Direction.NONE);
            mob.setRunningDirection(Direction.NONE);
            incrementRunEnergy();
            return;
        }

        // Process a single step.
        Direction firstStepDir = Direction.between(currentStep, nextStep);
        history.add(nextStep);
        mob.setLastDirection(firstStepDir);
        mob.setWalkingDirection(firstStepDir);
        currentStep = nextStep;

        // If we're running, process another step.
        if (running && decrementRunEnergy() && (nextStep = current.poll()) != null) {
            Direction nextStepDir = Direction.between(currentStep, nextStep);
            history.add(nextStep);
            mob.setLastDirection(nextStepDir);
            mob.setRunningDirection(nextStepDir);
            currentStep = nextStep;
        } else {
            mob.setRunningDirection(Direction.NONE);
            incrementRunEnergy(); // Restore run energy while not running.
        }

        mob.setPosition(currentStep.setZ(plane));
    }

    /**
     * Adds a pre-computed path to this walking queue.
     * <p>
     * <strong>Important:</strong> This method does <em>not</em> validate the path for correctness (no collision or
     * clipping checks). The walking queue will blindly attempt to walk every tile that is queued here. To safely queue
     * a destination-based path generated by the pathfinder, use {@link WalkingNavigator#walk(Locatable, boolean)} instead.
     *
     * @param path The path to walk as a sequence of absolute {@link Position} tiles.
     */
    public void addPath(Deque<Position> path) {
        if (!path.isEmpty()) {
            addFirst(path.poll());
            for (; ; ) {
                Position nextPosition = path.poll();
                if (nextPosition == null) {
                    break;
                }
                add(nextPosition);
            }
        }
    }

    /**
     * Adds a single step in the specified direction to this walking queue.
     * <p>
     * <strong>Important:</strong> This is a low-level helper that does <em>not</em> do any collision, clipping, or
     * reachability checks. The resulting step may be invalid if the destination tile is blocked. Higher-level systems
     * are responsible for ensuring that this call only produces valid movement.
     *
     * @param direction The direction to step from the mob's current position.
     */
    public void addStep(Direction direction) {
        addFirst(mob.getPosition().translate(1, direction));
    }

    /**
     * Clears both the current and previous steps for this walking queue.
     * <p>
     * After calling this, the mob will remain stationary until new steps are queued.
     */
    public void clear() {
        current.clear();
        history.clear();
    }

    /**
     * Returns the number of remaining queued tiles in this walking queue.
     *
     * @return The amount of remaining steps.
     */
    public int size() {
        return current.size();
    }

    /**
     * Returns whether there are no remaining steps in this walking queue.
     *
     * @return {@code true} if this walking queue is empty, otherwise {@code false}.
     */
    public boolean isEmpty() {
        return size() == 0;
    }

    /**
     * Adds an initial step to this walking queue, potentially backtracking through the movement history.
     * <p>
     * Semantics:
     * <ul>
     *     <li>Clears the current queue.</li>
     *     <li>Walks backwards through {@link #history} until it finds the requested tile, collecting the intermediate
     *     tiles used to reach that point.</li>
     *     <li>If the tile is found in history, replays those backtracked steps into {@link #current} so the mob can
     *     smoothly walk back to that tile and then continue from there.</li>
     *     <li>If the tile is not found in history, simply starts a new path from that tile.</li>
     * </ul>
     *
     * @param step The first step of the new path.
     */
    private void addFirst(Position step) {
        current.clear();
        Queue<Position> backtrack = new ArrayDeque<>();
        for (; ; ) {
            Position prev = history.pollLast();
            if (prev == null) {
                break;
            }
            backtrack.add(prev);
            if (prev.getX() == step.getX() && prev.getY() == step.getY()) {
                backtrack.forEach(this::add);
                history.clear();
                return;
            }
        }
        history.clear();
        add(step);
    }

    /**
     * Adds a non-initial step to this walking queue.
     * <p>
     * The supplied position is an absolute destination tile. If that destination is more than one tile away from the
     * last queued step, this method will fill in all intermediate tiles so that the resulting path is continuous.
     *
     * @param next The next step to add, as an absolute position.
     */
    private void add(Position next) {
        Position last = current.peekLast();
        if (last == null) {
            last = mob.getPosition();
        }
        int nextX = next.getX();
        int nextY = next.getY();
        int deltaX = nextX - last.getX();
        int deltaY = nextY - last.getY();

        int max = Math.max(Math.abs(deltaX), Math.abs(deltaY));

        for (int count = 0; count < max; count++) {
            if (deltaX < 0) {
                deltaX++;
            } else if (deltaX > 0) {
                deltaX--;
            }

            if (deltaY < 0) {
                deltaY++;
            } else if (deltaY > 0) {
                deltaY--;
            }
            current.add(new Position(nextX - deltaX, nextY - deltaY));
        }
    }

    /**
     * Depletes run energy for a player if they are running.
     * <p>
     * The depletion rate is based on the player's carried weight. If run energy reaches zero, this method will:
     * <ul>
     *     <li>Set the player's run energy to {@code 0}.</li>
     *     <li>Disable running on the player.</li>
     * </ul>
     *
     * @return {@code true} if the player still has run energy remaining and can continue running, otherwise {@code false}.
     */
    private boolean decrementRunEnergy() {
        if (mob.getType() != EntityType.PLAYER) {
            return true;
        }
        Player player = (Player) mob;
        if (player.getRunEnergy() <= 0.0) {
            return false;
        }
        double totalWeight = player.getWeight();
        double energyReduction = 0.117 * 2 * Math
                .pow(Math.E, 0.0027725887222397812376689284858327062723020005374410 * totalWeight);
        double newValue = player.getRunEnergy() - energyReduction;
        if (newValue <= 0.0) {
            player.setRunEnergy(0.0, true);
            player.setRunning(false);
            return false;
        }
        player.setRunEnergy(newValue, true);
        return true;
    }

    /**
     * Restores run energy for a player while they are not running.
     * <p>
     * The restoration rate is based on the player's current Agility level. Run energy is clamped to a maximum of
     * {@code 100.0}.
     */
    private void incrementRunEnergy() {
        if (mob.getType() != EntityType.PLAYER)
            return;
        Player player = mob.asPlr();

        double runEnergy = player.getRunEnergy();
        if (runEnergy >= 100.0) {
            return;
        }

        double agilityLevel = player.skill(Skill.AGILITY).getLevel();
        double energyRestoration = 0.096 * Math
                .pow(Math.E, 0.0162569486104454583293005993255170468638949631744294 * agilityLevel);
        double newValue = runEnergy + energyRestoration;
        newValue = Math.min(newValue, 100.0);

        player.setRunEnergy(newValue, true);
    }

    /**
     * Sets whether the current path should be treated as a running path.
     * <p>
     * When enabled, {@link #process()} will attempt to consume up to two tiles per cycle, subject to available run
     * energy.
     *
     * @param running {@code true} to enable running, {@code false} to disable.
     */
    public void setRunning(boolean running) {
        this.running = running;
    }

    /**
     * Returns whether movement is currently locked for this mob.
     *
     * @return {@code true} if movement is locked, otherwise {@code false}.
     */
    public boolean isLocked() {
        return locked;
    }

    /**
     * Locks or unlocks movement for this mob.
     * <p>
     * When movement is locked:
     * <ul>
     *     <li>All queued steps and history are cleared.</li>
     *     <li>{@link #process()} will not move the mob until it is unlocked.</li>
     * </ul>
     *
     * @param locked {@code true} to lock movement and clear the queue, {@code false} to unlock.
     */
    public void setLocked(boolean locked) {
        if (locked) {
            clear();
        }
        this.locked = locked;
    }
}
